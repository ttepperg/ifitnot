!       ------------------------------------------------------------------------
!       Voigt-Profile approximation to model absorption lines
!       ------------------------------------------------------------------------
!       (C) Thorsten Tepper Garcia 2008
!       Based on the approximation to the Voigt-Hjerting function
!       published in:
!       Tepper Garcia, Thorsten
!       Monthly Notices of the Royal Astronomical Society; Volume 369, 
!       Issue 4, Page 2025
!       Please refer to the author when using this approximation.

!       ========================================================================
        module set_precision

!       ------------------------------------------------------------------------
!       shamelessly stolen from SpecWizard (by Schaye, Booth, and Theuns)

!       set precision of single and real(kind=doubleR) real and integers
        integer, parameter :: singleR = selected_real_kind(p=6,r=37)
        integer, parameter :: doubleR = selected_real_kind(p=15,r=307)
        integer, parameter :: singleI = selected_int_kind(9)
        integer, parameter :: doubleI = selected_int_kind(18)

!       signal invalid values
        real(kind=doubleR), parameter :: invalid_R = -1.0d99
        integer(kind=singleI), parameter :: invalid_I = -1234567890
        character(len=20), parameter  :: invalid   = 'INVALID'

!       generic
        real(kind=singleR) :: real_single
        real(kind=doubleR) :: real_double

        end module set_precision
!       ========================================================================

!       ========================================================================
        module abs_lines
        use set_precision

!       ------------------------------------------------------------------------
!       atomic variables
!       derived (user-defined) type

        type single_t
         sequence             ! store data elements next to each other in memory
         real(kind=doubleR) :: lambda_0, f_osc, big_gamma ! fundamental quant.
         real(kind=doubleR) :: tau_0
        end type single_t

!       ------------------------------------------------------------------------
!       absorption component parameters;
!       derived (user-defined) type

        type absorption_line
         sequence
         real(kind=doubleR) :: vel_c, col_dens, b_value
         real(kind=doubleR) :: z_abs
         real(kind=doubleR) :: eq_width
        end type absorption_line
       
        type ion
         sequence
         character(len=10) :: name
         real(kind=doubleR) :: mass
         integer(kind=singleI) :: num_transitions
         type(single_t), allocatable :: transition(:)
         type(absorption_line), allocatable :: component(:)
        end type ion

        integer(kind=singleI) :: num_ions
        integer(kind=singleI) :: ION_INDEX

        type(ion), allocatable :: IONS(:)       ! main working structure

        end module abs_lines
!       ========================================================================

!       ========================================================================
        module physical
        use set_precision

!        Physical parameters (cgs UNITS)

        real(kind=doubleR), parameter :: sigma0=6.3d-18
        real(kind=doubleR), parameter :: c_cms=2.9979d+10
        real(kind=doubleR), parameter :: c_kms=c_cms * 1.0d-5
        real(kind=doubleR), parameter :: radius_e=2.817d-13
        real(kind=doubleR), parameter :: pi=3.141593d0
        real(kind=doubleR), parameter :: charge_e=1.602d-19
        real(kind=doubleR), parameter :: mass_e=9.109d-34

        real(kind=doubleR), parameter :: atom_munit = 1.66053886e-24 ! g
        real(kind=doubleR), parameter :: boltzmann=1.3806504d-23 !J/K

        end module physical
!       ========================================================================


!       ------------------------------------------------------------------------
        program abs_line_profile_multiplet
!       ------------------------------------------------------------------------

!       Absorption Lines are calculated according to the
!       approximation for a<<1 (where a is the damping parameter in the
!       Voigt-Hjerting function H(a,x)) given by (Tepper Garcia 2006)
!       
!       H(a,x) = h0-a/sqrt(pi)/x^2*(h0^2*(4x^4 + 7x^2 + 4 + Q) - 1 - Q)
!       with h0=exp(-x^2), Q=1.5/x^2
!
!       The arguments of the program are a transition in the form e.g.
!       OVI_1031 (see ions.dat for a list of the avaible transitison),
!       the Doppler parameter 'b' (in units km/s) and the logarithmic
!       column density 'log10_coldens' (in units of log10(cm^{-2})).
!
!       The output of the program is:
!       a) a file named eqw.dat listing
!       log10_coldens | b | equivalent width (mili-Angstroem)
!       b) a plot of the line profile as a function of wavelength and
!       velocity (with respect to the line center). This plot should be
!       displayed automatically) 
!
!       Graphical output is supressed if plot = 'F'
!       All physical and other needed parameters are included in the file
!       'parameter.f'. The wavelength (and velocity) range is automatically
!       computed with a pixel size of 0.001 A.
!
!       The line parameters (central wavelength of the transition,
!       oscillator strength, and IONS(ionindex)%transitions(count_trans)%big_gamma- (damping-) value) are contained
!       in the file 'ions.dat', and were taken from Morton's Compilation
!       (see Tepper-Garcia 2006 for corresponding reference).
!
!       NOTE: The author is not responsible for any modifications
!       done to this code in its original form.
!
!       Please report any bugs or problems to:
!       mail@thorsten.mx

!       ------------------------------------------------------------------------
!       Variables declaration
!       ------------------------------------------------------------------------
        use set_precision
        use abs_lines
        use physical

        implicit none

        integer(kind=singleI) :: pixel, spectrum_size_px
        integer(kind=singleI) :: seed

        integer(kind=singleI) :: i,j

        integer(kind=singleI) :: ionindex, count_trans

        real(kind=doubleR) :: fwhm_kms
        
        real(kind=doubleR), allocatable :: flux(:), flux_conv(:)

        real(kind=doubleR), allocatable :: gaussdev(:)

        real(kind=doubleR), allocatable :: wavelength(:), velocity(:)
        real(kind=doubleR), allocatable:: sigma(:), noise(:)
        real(kind=doubleR) :: flux_noisy
        real(kind=doubleR) :: profile_func

        real(kind=doubleR) :: wl_min, wl_max, vel_min, vel_max, wl_range
        real(kind=doubleR) :: min_lambda_0 = huge(real_single)
        real(kind=doubleR) :: max_lambda_0 = 0.0d0

        real(kind=doubleR) :: tau_neg, tau_central, flux_central
        real(kind=doubleR) :: coldens, bvalue, zabs
        real(kind=doubleR) :: lambda0, fosc, biggamma, tau0, damping
        real(kind=doubleR) :: m_ion
        real(kind=doubleR) :: temp
        real(kind=doubleR) :: eqw_aux_nc , eqw_aux_cv


        real(kind=doubleR) :: voigt_hjerting, gauss
        real(kind=doubleR) :: gasdev
        real(kind=doubleR) :: minnoise=1.0d-3
        real(kind=doubleR) :: signaltonoise

        real(kind=doubleR) :: pixel_size_Ang                      !in Angstroem
        real(kind=doubleR), parameter :: pixel_size_kms = 1.0d0   !in km/s

        character(len=24) :: ion_name
        character(len=256) :: homedir

!       default input-parameter file
        character(len=256), parameter :: parfile_gen = 'alp_multip_param.gen'

!       default atomic data file prefix
        character(len=256), parameter ::
     &  atomdata_file_prefix='/ifitnot/atom_data.'

        character(len=256) :: infile, outfile_alp, outfile_ifit,
     +  plotfile, psfile, outfile_prefix
        character(len=256) :: command

        character(len=10) :: signaltonoise_str, fwhm_kms_str, profile_str,
     +  psplot_str

        character(len=256) :: errmsg, warnmsg, statmsg
        
        logical :: file_exists
        logical :: addnoise
        
!       ------------------------------------------------------------------------
!       Define program error and warning messages;
!       The lines below are meant to print the different
!       messages in different colors

!       In red=31
        errmsg=CHAR(27)//'[1;31mERROR: abs_line_profile_multiplet ...'//
     &  CHAR(27)//'[0m'
!       In yellow=33
        warnmsg=CHAR(27)//'[1;33mWARNING: abs_line_profile_multiplet ...'//
     &  CHAR(27)//'[0m'
!       In green=32
        statmsg=CHAR(27)//'[1;32mSTATUS: abs_line_profile_multiplet ...'//
     &  CHAR(27)//'[0m'

!       ------------------------------------------------------------------------
!       input parameters
!       ------------------------------------------------------------------------

!       check file
        inquire(file=trim(parfile_gen),exist=file_exists)

!       if file doesn't exist, stop cleanly
        if (.not.file_exists) then
         write(6,'(1x,a)') trim(errmsg)
         write(6,'(1x,a)') 'input-parameter file '//trim(parfile_gen)//
     &   ' does not exist'
         stop 1
        end if

!       otherwise open and read parameter values:
        open(3,file=trim(parfile_gen))

!       general parameters
         read(3,*) !comment line
         read(3,*) profile_str
         read(3,*) fwhm_kms
         read(3,*) signaltonoise
         read(3,*) psplot_str

!       ion list
         read(3,*) !comment line
         read(3,*) !comment line
         read(3,*) !comment line
         read(3,*) !comment line
         read(3,*) num_ions
        
!       quick input-parameter check
        ionindex = 0
         do
          ionindex = ionindex + 1
          read(3,*,end=10)
         end do

  10     continue

        if (((ionindex-1).ne.num_ions)) then
         write(6,*) trim(errmsg)
         write(6,*)
     &  'Non-matching input number and list of ions in input parameter file!'
         stop 1
        end if

!       if ok, continue to read ion names:

!       rewind file by num_ions+1 lines
         do ionindex=1,num_ions+1
          backspace(3)
         end do

!       allocate ion structure
         allocate(IONS(num_ions))

         do ionindex=1,num_ions

          allocate(IONS(ionindex)%component(1))

          read(3,*) IONS(ionindex)%name,
     &    IONS(ionindex)%component(1)%col_dens,
     &    IONS(ionindex)%component(1)%b_value,
     &    IONS(ionindex)%component(1)%z_abs

         end do

!       continue input-parameter check (only line profile for now)

        if ((profile_str.ne.'gauss').and.(profile_str.ne.'voigt')) then
         write(6,*) trim(errmsg)
         write(6,*) 'Non-valid profile : '//trim(profile_str)
         stop 1
        end if

!       set derived parameter values

        if (signaltonoise.gt.0.0d0) then
         addnoise=.true.
         write (signaltonoise_str,'(f5.2)') signaltonoise
        else
         signaltonoise=1.0d3
         addnoise=.false.
         write (signaltonoise_str,'(i4)') 1000
        end if

        write (fwhm_kms_str,'(f6.2)') fwhm_kms

!       ------------------------------------------------------------------------
!       Computation
!       ------------------------------------------------------------------------
!       Define home directory
        
        call system('echo $HOME > homedir')
        open(5,file='homedir')
        read(5,'(a)') homedir
        close(5)
        
!       ------------------------------------------------------------------------
        do i=1,num_ions

         ion_name = IONS(i)%name

!       open file and read data

         open(10,file=trim(homedir)//trim(atomdata_file_prefix)//trim(ion_name))

          read(10,*) IONS(i)%name, IONS(i)%mass, IONS(i)%num_transitions

!       allocate and read data for each transition
          allocate(IONS(i)%transition(IONS(i)%num_transitions))

          do j=1,IONS(i)%num_transitions
           read(10,*)
     &     IONS(i)%transition(j)%lambda_0,
     &     IONS(i)%transition(j)%big_gamma,
     &     IONS(i)%transition(j)%f_osc
          end do

         close(10)

!       consistency check
         if (trim(ion_name).ne.trim(IONS(i)%name)) then
          write(6,*) 'Incorrect ion name '//trim(IONS(i)%name)//
     &    ' in file '//trim(atomdata_file_prefix)//trim(ion_name)
          stop 1
         end if

!        set central (constant) optica depth (in cm^2 km/s)

         IONS(i)%transition(:)%tau_0 = (dsqrt(pi) * radius_e * c_kms) *
     &   (IONS(i)%transition(:)%f_osc *
     &   IONS(i)%transition(:)%lambda_0) * 1.0d-8

!       overal minimum / maximum observed absorption wavelengths
         min_lambda_0 = min(min_lambda_0,
     &   (1.0d0 + IONS(i)%component(1)%z_abs) *
     &   minval(IONS(i)%transition(:)%lambda_0)
     &   )

         max_lambda_0 = max(max_lambda_0,
     &   (1.0d0 + IONS(i)%component(1)%z_abs) *
     &   maxval(IONS(i)%transition(:)%lambda_0)
     &   )

        end do ! over ions

!       ------------------------------------------------------------------------

!       ------------------------------------------------------------------------
!       Define wavelength range

!       compute wavelength boundaries
        wl_min = min_lambda_0 - max(5.0d2,5.0d-2*(max_lambda_0-min_lambda_0))
        wl_max = max_lambda_0 + max(5.0d2,5.0d-2*(max_lambda_0-min_lambda_0))

!       Define wavelength range (2x the range spanned by the transitions)
        wl_range = wl_max - wl_min

!       Compute pixel size in Angstroem
        pixel_size_Ang = (pixel_size_kms * wl_min) /
     &  (c_kms)

!       allocate and initialise vectors 
        spectrum_size_px = ceiling(wl_range/pixel_size_Ang)

        allocate(flux(1:spectrum_size_px))
        allocate(flux_conv(1:spectrum_size_px))
        allocate(wavelength(1:spectrum_size_px))
        allocate(velocity(1:spectrum_size_px))
        allocate(sigma(1:spectrum_size_px))
        allocate(noise(1:spectrum_size_px))
        allocate(gaussdev(1:spectrum_size_px))

        flux(:) = 0.0d0
        wavelength(:) = 0.0d0
        velocity(:) = 0.0d0
        sigma(:) = 0.0d0
        noise(:) = 0.0d0
        gaussdev(:) = 0.0d0

!       output info
        write(6,*)
     &  'SPECTRUM SIZE [PX]  PIXEL SIZE [A | km/s]   WAVELENGTH [A] MIN / MAX'
        write(6,'(6x,i6,6x,4f12.4)')
     &  spectrum_size_px, pixel_size_Ang, pixel_size_kms, wl_min, wl_max

!       ------------------------------------------------------------------------
!       Generate Gaussian random numbers (mean = 0, dispersion = 1)

!       Initialisation seed (has to be a negative integer)
        
        gaussdev(:) = 0.0d0
        
        if (addnoise) then
         seed= 0
         do pixel=1,spectrum_size_px
          gaussdev(pixel) = gasdev(seed)
         end do
        end if

!       The minimum noise value should be constrained by the given S/N:
!       Not sure about this...
        minnoise = min(minnoise,1.0d-1/signaltonoise)

!       ------------------------------------------------------------------------
!       calculate optical depth as a function of v/c
!       ------------------------------------------------------------------------

!       ------------------------------------------------------------------------
!       compute spectrum
!       ------------------------------------------------------------------------
!       initialise flux
        
        flux(:) = 1.0d0

!       loop over ions

        DO ionindex=1,num_ions

         write(6,'(a)') 'processing ion: '//trim(IONS(ionindex)%name)

!       component parameters

        coldens = IONS(ionindex)%component(1)%col_dens
        bvalue = IONS(ionindex)%component(1)%b_value
        zabs = IONS(ionindex)%component(1)%z_abs

!       loop over transitions
        
        DO count_trans=1,IONS(ionindex)%num_transitions
        
        profile_func = 0.0d0

!       transition parameters

        lambda0 = IONS(ionindex)%transition(count_trans)%lambda_0
        fosc = IONS(ionindex)%transition(count_trans)%f_osc
        biggamma = IONS(ionindex)%transition(count_trans)%big_gamma
        tau0 = IONS(ionindex)%transition(count_trans)%tau_0

!       damping parameter
        damping = (lambda0 * biggamma / (4.0d0*pi*bvalue))*1.0d-13

!       central optical depth
        tau_central = tau0 * (coldens/bvalue)

!       flux at line's centre;
!       check numerical precision
        if ((-1.0d0*tau_central).le.(dlog(tiny(1.0d0)))) then
         flux_central = 0.0d0
        else
         flux_central = dexp(-1.0d0*tau_central)
        end if

        do pixel=1,spectrum_size_px

         wavelength(pixel) = wl_min + (pixel-1) * pixel_size_Ang

!       velocity scale [km/s] centred at bluest observed transition

         velocity(pixel) =
     &   (c_kms) * dlog(wavelength(pixel) / min_lambda_0)

!       optical depth; check for numerical precision

         if (profile_str.eq.'voigt')
     &    profile_func =
     &    voigt_hjerting(damping,bvalue,(1.0d0+zabs)*lambda0,
     &    wavelength(pixel))
         
         if (profile_str.eq.'gauss')
     &    profile_func = gauss(bvalue,(1.0d0+zabs)*lambda0,
     &    wavelength(pixel))
        
         if (profile_func.eq.0.0d0) then ! compiler warns about this
          tau_neg = 0.0d0
         else if ((dlog10(tau_central)+dlog10(profile_func)).lt.
     &    dlog10(tiny(1.0d0))) then
          tau_neg = 0.0d0
         else
          tau_neg = (-tau_central)*profile_func
         end if

!       flux; check numerical precision
         if (tau_neg.le.dlog(dsqrt(tiny(1.0d0))*signaltonoise)) then
          flux(pixel) = 0.0d0
         else
          flux(pixel) = flux(pixel) * dexp(tau_neg)
         end if
        
!       compute wavelength/velocity boundaries
         if (pixel.eq.1) vel_min = velocity(pixel)
         if (pixel.eq.spectrum_size_px) vel_max = velocity(pixel)

        end do ! over pixel

        END DO ! over transitions

        END DO ! over ions

!       ------------------------------------------------------------------------
!       convolve spectrum
!       ------------------------------------------------------------------------

        flux_conv(:) = flux(:)

        if (fwhm_kms.gt.0.0d0)
     &  call convolve_spectrum(flux_conv,spectrum_size_px,pixel_size_kms,fwhm_kms)

!       ------------------------------------------------------------------------
!       OUTPUT
!       ------------------------------------------------------------------------

!       Define common filename prefix

        outfile_prefix = 'output_data/abs_line_profile_multiplet_ions'//
     &  '_SN'//trim(adjustl(signaltonoise_str))//'_FWHM'//
     &  trim(adjustl(fwhm_kms_str))

!       OUTPUT 1: to be shown graphically

        outfile_alp = trim(outfile_prefix)//'.alp'

!       OUTPUT 2: used for ifitnot benchmarking

        outfile_ifit = trim(outfile_prefix)//'.ifit'

        open(60,file=trim(outfile_ifit))

        open(50,file=trim(outfile_alp))
         
         eqw_aux_nc = 0.0d0
         eqw_aux_cv = 0.0d0

         do pixel=1,spectrum_size_px

!       add noise; check numerical precision
          
          sigma(pixel) = sqrt( minnoise**2.0 +
     &   (flux_conv(pixel)/signaltonoise)**2.0 )
        
          noise(pixel) = sigma(pixel)*gaussdev(pixel)

          if (flux_conv(pixel).le.(tiny(1.0d0) - noise(pixel))) then
           flux_noisy = flux_conv(pixel) + abs(noise(pixel))
          else
           flux_noisy = flux_conv(pixel) + noise(pixel)
          end if

!       Equivalent width
          eqw_aux_nc = eqw_aux_nc + (1.0d0 - flux(pixel))*pixel_size_Ang
          eqw_aux_cv = eqw_aux_cv + (1.0d0 - flux_conv(pixel))*pixel_size_Ang

          write(50,*) velocity(pixel),
     &    wavelength(pixel),
     &    flux_noisy, flux(pixel), flux_conv(pixel)

          write(60,*) wavelength(pixel), flux_noisy, sigma(pixel)
        
         end do
        
        close(50)

        close(60)

!       ----------------------------------------------------------------
!       Create gnuplot file 2
        
        if (psplot_str.ne.'FALSE') then

!       Define psfile name
        psfile=trim(outfile_prefix)//'multi_alp.ps'

!       Define plotfile name
        plotfile=trim(outfile_prefix)//'multi_alp.plot'

!       Define title
        infile = trim(ion_name)

        call create_plotfile_multiplet(infile,outfile_ifit,plotfile,psfile,
     &  signaltonoise)

!       Compile with gnuplot
        command='gnuplot '//trim(plotfile)
        call system(trim(command))

!       Open ps-file
        command='gv '//trim(psfile)//' &'
        call system(trim(command))
        
        end if ! plot

!       ------------------------------------------------------------------------
        end program
!       ------------------------------------------------------------------------

!       ========================================================================
!       Subroutines and Functions
!       ========================================================================

!       ------------------------------------------------------------------------
        real(kind=doubleR) function voigt_hjerting(a,b,cwl,wl)

!       Returns the value of the Voigt-Hjerting function H(a,x) as a
!       function of wavelength for a given a-parameter, Doppler
!       parameter (in km/s), and central wavelength (in Angstroem) of
!       the corresponding transition.

        use set_precision
        use physical, only: c_cms, pi

        implicit none

        real(kind=doubleR) :: a, b, dopp, cwl, wl
        real(kind=doubleR) :: x, x2, h0, Q, P
        
        dopp = (cwl*b/c_cms)*1.0d-3
        x = ((wl-cwl)/dopp)*1.0d-8

!       Check numerical precision
!       See ~/ifitnot/voigt_hjerting/code/precision (dir)

        if (dabs(x).gt.4.0d-4) then ! numerically stable

         x2 = x*x

!       avoid underflow of exp(-x*x)
         if (dabs(x).lt.(dsqrt(-dlog(dble(tiny(1.0e0)))))) then
          h0 = dexp(-1.0d0*x2)
         else
          h0 = tiny(1.0e0)
         end if
        
!       avoid over/underflow of Q
         if ((dlog(x2) + dlog(dble(tiny(1.0e0)))).gt.dlog(1.5d0)) then
          Q = tiny(1.0e0)
         else
          Q = 1.5d0/x2
         end if
        
!       avoid over/underflow of P
         if ((dlog(x2) + dlog(dble(tiny(1.0e0)))).gt.
     &   (dlog(a)-dlog(dsqrt(pi)))) then
          P = tiny(1.0e0)
         else
          P = a/dsqrt(pi)/x2
         end if
        
         voigt_hjerting = h0 - P *
     &   (h0*h0*(4.0d0*x2*x2 + 7.0d0*x2 + 4.0d0 + Q) - 1.0d0 - Q)

        else                         !limit for x -> 0

         voigt_hjerting = 1.0d0 - 2.0d0*a/dsqrt(pi)

        endif
        
        return
!       ------------------------------------------------------------------------
        end function voigt_hjerting
!       ------------------------------------------------------------------------

!       ------------------------------------------------------------------------
        real(kind=doubleR) function gauss(b,cwl,wl)

!       Returns the value of the Gaussian function as a function of
!       wavelength for a given Doppler parameter (in km/s), and central
!       wavelength (in Angstroem) of the corresponding transition.

        use set_precision
        use physical, only: c_cms

        implicit none

        real(kind=doubleR) :: b, dopp, cwl, wl
        real(kind=doubleR) :: x
        
        dopp = (cwl*b/c_cms)*1.0d-3
        x = ((wl-cwl)/dopp)*1.0d-8

!       check for numerical precision to avoid floating exception
        if (dabs(x).lt.(dsqrt(-dlog(dble(tiny(1.0e0)))))) then
         gauss = dexp(-1.0d0*x*x)
        else
         gauss = dble(tiny(1.0e0))
        end if

        return
!       ------------------------------------------------------------------------
        end function gauss
!       ------------------------------------------------------------------------

!       ------------------------------------------------------------------------
!       Numerical Recipes
!       ------------------------------------------------------------------------

!       ------------------------------------------------------------------------
!       GENERATES UNIFORMILY DISTRIBUTED RANDOM NUMBERS
              
        function ran1(idum)

        use set_precision

        implicit none

        integer(kind=singleI) :: idum
        real(kind=doubleR) :: ran1
        integer(kind=singleI), parameter :: IA=16807,IM=2147483647,IQ=127773,
     !  IR=2836, NTAB=32 ! edited by TTG
        real(kind=doubleR), parameter :: AM=1.0d0/dble(IM), ! edited by TTG
     !  NDIV=1.0d0+(dble(IM)-1.0d0)/dble(NTAB),EPS=1.2d-7,RNMX=1.0d0-EPS
        integer(kind=singleI) :: j,k,iv(NTAB),iy
        save iv,iy
        data iv /NTAB*0/, iy /0/
        if (idum.le.0.or.iy.eq.0) then
         idum=max(-idum,1)
         do 11 j=NTAB+8,1,-1
          k=idum/IQ
          idum=IA*(idum-k*IQ)-IR*k
          if (idum.lt.0) idum=idum+IM
          if (j.le.NTAB) iv(j)=idum
11       continue
         iy=iv(1)
         end if
         k=idum/IQ
         idum=IA*(idum-k*IQ)-IR*k
         if (idum.lt.0) idum=idum+IM
         j=int(1+iy/NDIV) ! edited by TTG
         iy=iv(j)
         iv(j)=idum
         ran1=min(AM*iy,RNMX)

         if (ran1.lt.0.0d0) then
          print*, 'ran1: negative random number!'
          print*, AM, iy, RNMX
          stop 1
         end if

         return
         end function
C  (C) Copr. 1986-92 Numerical Recipes Software 5.W7.
!       ------------------------------------------------------------------------

!       ------------------------------------------------------------------------
!       GENERATES GAUSSIAN DISTRIBUTED RANDOM NUMBERS

        function gasdev(idum)

        use set_precision

        implicit none

        integer(kind=singleI) :: idum
        real(kind=doubleR) :: gasdev
CU      USES ran1
        integer(kind=singleI) :: iset
        real(kind=doubleR) :: fac,gset,rsq,v1,v2,ran1
        SAVE iset,gset
        DATA iset/0/
        if (iset.eq.0) then
1        v1=2.0D0*ran1(idum)-1.0D0
         v2=2.0D0*ran1(idum)-1.0D0
         rsq=v1**2+v2**2
         if(rsq.ge.1.0d0.or.rsq.eq.0.0d0) goto 1 ! compiler warns about this
         fac=sqrt((-2.0D0)*dlog(rsq)/rsq)
         gset=v1*fac
         gasdev=v2*fac
         iset=1
        else
         gasdev=gset
         iset=0
        end if
        return
        end function
C  (C) Copr. 1986-92 Numerical Recipes Software 5.W7.
!       ------------------------------------------------------------------------

!       ------------------------------------------------------------------------
!       Stolen from SpecWizard
!       USES convlv

        subroutine convolve_spectrum(flx,num_px,px_size,fwhm)

!       flux = signal
!       spectrum_size_px = number of pixels
!       vpixsize = size of pixel in km/s
!       fwhm_kms = FWHM of Gaussian response in km/s

        use set_precision

        implicit none

        real(kind=doubleR) :: sigmakms, b, norm, fwhm, px_size
        integer(kind=singleI) :: i,j,off, nvpix, num_px
        real(kind=doubleR), allocatable, save :: gauss(:)
        real(kind=doubleR)  :: flx(*)
        real(kind=doubleR), allocatable  :: convl_flux(:),
     &  convl_flux_convolved(:)

!       determine number of pixels
        nvpix = num_px

!       Compute sigma in km/s
        sigmakms = fwhm / (2.0d0 * dsqrt( 2.0d0 * dlog(2.0d0)))

!       Compute sigma in units of pixels
        b = sigmakms / px_size
        
!       For convolution with instrumental PSF we need to Fourier 
!       transform, we thus need to increase the array so that it is a
!       power of 2.
        nvpix = int(2.0d0**(aint(dlog(dble(nvpix))/dlog(2.0d0)) + 1.0d0))
        
!       Create normalized Gaussian in wrap-around order (required by
!       convlv)

        allocate(gauss(nvpix))
        norm = 1.0d0 / (2.0d0 * b * b)
        do i = 0, nvpix-1
           if (i .le. nvpix-1) then 
              if (i .le. nvpix/2) then
                 j = i
              else
                 j = i - nvpix
              endif
              if (abs(j) .lt. 1.0d1*b) then
                 gauss(i+1) = exp(-(dble(j)**2.0d0)*norm)
              else
                 gauss(i+1) = 0.0d0
              endif
           else
              gauss(i+1) = 0.0d0
           endif
        enddo

!       normalise Gaussian
        gauss  = gauss / sum(gauss)

        allocate(convl_flux(nvpix),convl_flux_convolved(2*nvpix))
        convl_flux(:) = 0.0d0
        convl_flux(1:num_px) = flx(1:num_px)

!       copy periodic copies of the flux signal into the zero buffer
!       to avoid aliasing (or end) effects
        do i=num_px+1,nvpix
           off = i-num_px
           if (off .lt. (nvpix-num_px)/2.0d0) then
              convl_flux(i) = convl_flux(i-num_px)
           else
              convl_flux(i) = convl_flux(i-(nvpix-num_px))
           endif
        enddo
        convl_flux_convolved(:) = 0.0d0

        call convlv(convl_flux,nvpix,gauss,nvpix,1,convl_flux_convolved)

        flx(1:num_px) = convl_flux_convolved(1:num_px)

        deallocate(convl_flux,convl_flux_convolved)

!       ------------------------------------------------------------------------
!       output info

        write(6,'(a,f7.2)')
     &  'spectrum convolved with Gaussian LSF with FWHM [km/s]:', fwhm
        write(6,'(a,f7.2)')
     &  'over a wavelength range around line centre of width [pixel]', 1.0d1*b
        write(6,'(a,f7.2)')
     &  'over a wavelength range around line centre of width [km/s]',
     &   1.0d1*b*px_size
        write(6,*)

!       ------------------------------------------------------------------------
        return

        end subroutine convolve_spectrum
!       ------------------------------------------------------------------------

!       ------------------------------------------------------------------------
!       Stolen from SpecWizard
!       USES twofft; realft

        subroutine convlv(data,n,respns,m,isign,ans)

        use set_precision

        implicit none

        integer, intent(in) :: n, m, isign
        real(kind=doubleR), intent(in)    :: data(n)
        real(kind=doubleR), intent(inout) :: respns(n)
        double complex, intent(out):: ans(2*n)

        double complex, allocatable :: fft(:)

        integer i,no2
        integer, save :: nfft=-1

        if(nfft .ne. n)then
           allocate(fft(n))
           nfft = n
        endif

        do  i=1,(m-1)/2
           respns(n+1-i)=respns(m+1-i)
        enddo
        do  i=(m+3)/2,n-(m-1)/2
           respns(i)=0.0
        enddo

        call twofft(data,respns,fft,ans,n)
        no2=n/2
        do i=1,no2+1
           if (isign.eq.1) then
              ans(i)=fft(i)*ans(i)/no2
           else if (isign.eq.-1) then
              if (abs(ans(i)).eq.0.0) then
                write(*,*) 'deconvolving at response zero in convlv'
                stop
              end if
              ans(i)=fft(i)/ans(i)/no2
           else
              stop 'no meaning for isign in convlv'
           endif
        enddo
        ans(1)=dcmplx(dble(ans(1)),dble(ans(no2+1)))
        call realft(ans,n,-1)

        return
        end subroutine convlv
!       ------------------------------------------------------------------------

!       ------------------------------------------------------------------------
!       Stolen from SpecWizard
!       USES four1

        subroutine twofft(data1,data2,fft1,fft2,n)

        use set_precision

        implicit none

        integer, intent(in) :: n
        real(kind=doubleR), intent(in) :: data1(n), data2(n)
        double complex :: fft1(n), fft2(n)

        ! local variables
        integer j,n2
        double complex ::  h1,h2,c1,c2

        c1=dcmplx(0.5,0.0)
        c2=dcmplx(0.0,-0.5)
        do  j=1,n
           fft1(j)=dcmplx(data1(j),data2(j))
        enddo
        call four1(fft1,n,1)
        fft2(1)=dcmplx(imag(fft1(1)),0d0)
        fft1(1)=dcmplx(dble(fft1(1)),0d0)
        n2=n+2
        do j=2,n/2+1
           h1=c1*(fft1(j)+conjg(fft1(n2-j)))
           h2=c2*(fft1(j)-conjg(fft1(n2-j)))
           fft1(j)=h1
           fft1(n2-j)=conjg(h1)
           fft2(j)=h2
           fft2(n2-j)=conjg(h2)
        enddo
        return
        end subroutine twofft
!       ------------------------------------------------------------------------

!       ------------------------------------------------------------------------
!       Stolen from SpecWizard
!       USES four1

        subroutine realft(data,n,isign)

        use set_precision

        implicit none

        integer, intent(in) :: n, isign
        real(kind=doubleR), intent(inout) :: data(n)
        ! local variables
        integer i,i1,i2,i3,i4,n2p3
        real(kind=doubleR) c1,c2,h1i,h1r,h2i,h2r,wis,wrs
        real(kind=doubleR) theta,wi,wpi,wpr,wr,wtemp
        theta=3.141592653589793d0/dble(n/2)
        c1=0.5
        if (isign.eq.1) then
           c2=-0.5
           call four1(data,n/2,+1)
        else
           c2=0.5
           theta=-theta
        endif
        wpr=-2.0d0*sin(0.5d0*theta)**2
        wpi=sin(theta)
        wr=1.0d0+wpr
        wi=wpi
        n2p3=n+3
        do  i=2,n/4
           i1=2*i-1
           i2=i1+1
           i3=n2p3-i2
           i4=i3+1
           wrs=sngl(wr)
           wis=sngl(wi)
           h1r=c1*(data(i1)+data(i3))
           h1i=c1*(data(i2)-data(i4))
           h2r=-c2*(data(i2)+data(i4))
           h2i=c2*(data(i1)-data(i3))
           data(i1)=h1r+wrs*h2r-wis*h2i
           data(i2)=h1i+wrs*h2i+wis*h2r
           data(i3)=h1r-wrs*h2r+wis*h2i
           data(i4)=-h1i+wrs*h2i+wis*h2r
           wtemp=wr
           wr=wr*wpr-wi*wpi+wr
           wi=wi*wpr+wtemp*wpi+wi
        enddo
        if (isign.eq.1) then
           h1r=data(1)
           data(1)=h1r+data(2)
           data(2)=h1r-data(2)
        else
           h1r=data(1)
           data(1)=c1*(h1r+data(2))
           data(2)=c1*(h1r-data(2))
           call four1(data,n/2,-1)
        endif
        return
        end subroutine realft
!       ------------------------------------------------------------------------

!       ------------------------------------------------------------------------
!       Stolen from SpecWizard

        subroutine four1(data,nn,isign)

        use set_precision

        implicit none

        integer, intent(in) :: nn, isign
        real(kind=doubleR), intent(inout) :: data(2*nn)
        ! local variables  
        integer i,istep,j,m,mmax,n
        real(kind=doubleR) :: tempi,tempr
        real(kind=doubleR) ::  theta,wi,wpi,wpr,wr,wtemp

        n=2*nn
        j=1
        do  i=1,n,2
           if(j.gt.i)then
              tempr=data(j)
              tempi=data(j+1)
              data(j)=data(i)
              data(j+1)=data(i+1)
              data(i)=tempr
              data(i+1)=tempi
           endif
           m=n/2
1         if ((m.ge.2).and.(j.gt.m)) then
              j=j-m
              m=m/2
              goto 1
         endif
         j=j+m
        enddo
        mmax=2
2        if (n.gt.mmax) then
        istep=2*mmax
        theta=6.28318530717959d0/(isign*mmax)
        wpr=-2.d0*sin(0.5d0*theta)**2
        wpi=sin(theta)
        wr=1.d0
        wi=0.d0
        do m=1,mmax,2
           do  i=m,n,istep
              j=i+mmax
              tempr=sngl(wr)*data(j)-sngl(wi)*data(j+1)
              tempi=sngl(wr)*data(j+1)+sngl(wi)*data(j)
              data(j)=data(i)-tempr
              data(j+1)=data(i+1)-tempi
              data(i)=data(i)+tempr
              data(i+1)=data(i+1)+tempi
           enddo
           wtemp=wr
           wr=wr*wpr-wi*wpi+wr
           wi=wi*wpr+wtemp*wpi+wi
        enddo
        mmax=istep
        goto 2
        endif
        return
        end subroutine four1
!       ------------------------------------------------------------------------

!       ----------------------------------------------------------------
        subroutine create_plotfile(datfile,linefile,gpfile,psline,
     &  tau_0,f_0,col_dens,b_par,wlmin,wlmax,velmin,velmax,eqw,
     &  wl_0,fosc,damp,temp,sn)

!       To plot a 3D color map from a data file with three columns
!       (x:y:z)
!       where each 'iso_line' must be separated by a blank line
!
        use set_precision
        use physical

        implicit none

        integer(kind=singleI) :: i

        integer(kind=singleI) :: datetime(8)
        integer(kind=singleI) :: clock

        real(kind=doubleR) :: col_dens,b_par,eqw,
     &  tau_0, f_0, wl_0, fosc, damp, temp, sn

        real(kind=doubleR) :: wlmin, wlmax, velmin, velmax

        character(len=256), intent(in) :: linefile, gpfile, psline

        character(len=10) :: datetime_str(8)

        character(len=256) :: datfile, fontpath, fontfile, timestamp

        character(len=10) :: date, time, zone

!       ------------------------------------------------------------------------
!       Get time stamp (include from fitfile to uniquely identify files)
        call date_and_time(date, time, zone, datetime)
        call system_clock(clock)

!       Write datime into a string (for later use)
        write(datetime_str(:),'(i5)') datetime(:)
        timestamp = trim(adjustl(datetime_str(1)))//'/'//
     &  trim(adjustl(datetime_str(2)))//'/'//trim(adjustl(datetime_str(3)))
     &  //'-'//trim(adjustl(datetime_str(4)))//'-'//
     &  trim(adjustl(datetime_str(5)))//'.'//trim(adjustl(datetime_str(6)))
     &  //'.'//trim(adjustl(datetime_str(7)))//'.'//
     &  trim(adjustl(datetime_str(8)))

!       ----------------------------------------------------------------
!       Redefine datfile name (to be used as title for the plot) to
!       to replace underscores by minuses
        do i=1,len_trim(datfile)
         if (datfile(i:i).eq.'_') datfile(i:i)='-'
        end do

!       Open file
        open(40,file=trim(gpfile))

         write(40,*) '# ------------------------------------------------'
         write(40,*) '# line profile plot'
         write(40,*) '# Generated by abs_line_profile_multiplet'
         write(40,*) '# ------------------------------------------------'
         write(40,*)
         write(40,*) '# Reset for a clean start'
         write(40,*) 'reset'
         write(40,*)
         write(40,*) '# Set general plot options'
         write(40,*)
         write(40,*) '# Key'
         write(40,*) 'set key top right'
         write(40,*)

!       Define fontpath for fancy symbols
         fontpath='/usr/share/texmf/fonts/type1/bluesky/cm/'
         write(40,*) '# Set font path'
         write(40,*) '# set fontpath '''//trim(fontpath)//''
         write(40,*) '# Set term x11 and font cmsy10.pfb for special '
         write(40,*) '# symbols (CMSY10 font) in OMS encoding'
         write(40,*) '# (see table ~/ps_fontfile_doc.ps)'
         write(40,*)

!       Define fontfile for fancy symbols
         fontfile='cmsy10.pfb'
!        write(40,*) 'set term post enhanced color fontfile '''
!     &   //trim(fontfile)//''' dashlength 1'
         write(40,*) 'set term post enhanced color dashlength 1'
         write(40,*)
         write(40,*) '# Set output filename'
         write(40,*) 'set output "'//trim(psline)//'"'
         write(40,*)
         write(40,*) '# For fancy symbol fonts'
         write(40,*) 'set encoding iso_8859_1'
         write(40,*)

!       Set title of plot; size is modified via {/=<size> <text>}
         write(40,*) '# Set title'
         write(40,*) 'set title "{/=12 '//trim(datfile)//'}"'
         write(40,*)

         write(40,*) '# Set time stamp'
         write(40,*) '#set label "',clock,'" at graph 0.8, 0.9'
         write(40,*) '# centered, below title'
         write(40,*) '#set label "{/=6 '//trim(timestamp)//'}" at '
     &   //'graph 0.45, 1.02'
         write(40,*) '# top right edge'
         write(40,*) '#set label "{/=6 '//trim(timestamp)//'}" at '
     &   //'graph 0.9, 1.08'
         write(40,*)

         write(40,*) '# Set text labels'
         write(40,'(a,1pe8.2,a)') 'set label "{/=18 S/N=',
     &   sn,'}" tc rgb "royalblue" at graph 0.05, 0.9'

         write(40,'(a,1pe12.2,a)') 'set label "{/=12 equivalent width '
     &   //'[m \305] = ',eqw,'}" at graph 0.05, 0.32'

         write(40,'(a,1pe12.2,a)') 'set label "{/=12 central optical depth = ',
     &   tau_0,'}" at graph 0.05, 0.28'

         write(40,'(a,1pe10.2e3,a)') 'set label "{/=12 flux at central opt.depth = ',
     &   f_0,'}" at graph 0.05, 0.24'

         write(40,'(a,f5.2,a)') 'set label "{/=12 log_{10} N_{ion} = ',
     &   col_dens,'}" at graph 0.05, 0.16'

         write(40,'(a,f6.2,a)') 'set label "{/=12 b-value = ',
     &   b_par,'}" at graph 0.05, 0.12'

         write(40,'(a,f5.2,a)') 'set label "{/=18 log (T/K) =',
     &   dlog10(temp),'" left tc rgb "red" at graph 0.75, 0.32'

         write(40,'(a,f5.2,a)') 'set label "{/=18 log (N/b) =',
     &   col_dens-dlog10(b_par),'" left tc rgb "black" at graph 0.75, 0.24'

         write(40,'(a,e10.4,a)') '#set label "{/=12 f'
     &   //'_{osc} = ', fosc,'}" at graph 0.8, 0.20'

         write(40,'(a,e10.4,a)') '#set label "{/=12 {/Symbol G}'
     &   //' = ', damp,' s^{-1}}" at graph 0.8, 0.16'

         write(40,'(a,f7.2,a)') '#set label "{/=12 {/Symbol l}'
     &   //'_{0} = ', wl_0,' \305}" at graph 0.8, 0.24'

         write(40,*)
         write(40,*) '# tics format (default)'
         write(40,*) 'set xtics nomirror format "{/=14% g}"'
         write(40,*) 'set x2tics nomirror format "{/=14% g}"'
         write(40,*) 'set ytics format "{/=14% g}"'
         write(40,*)

!       Set minor tics on both axes
         write(40,*) '# Set minor tics on all axes'
         write(40,*) 'set mxtics'
         write(40,*) 'set mx2tics'
         write(40,*) 'set mytics'
         write(40,*)

!       Set axes labels; size is modified via {/=<size> <text>}
         write(40,*) '# Set axes label'
         write(40,*) 'set xlabel "{/=14 {/Symbol l - l_{0}} [\305]"'
         write(40,*) 'set x2label "{/=14 Velocity [km s^{ -1}]}"'
         write(40,*) 'set ylabel "{/=14 Transmission}"'
         write(40,*)

         write(40,*) '# Set xy-range'
         write(40,*) 'set xrange [',wlmin,':',wlmax,']'
         write(40,*) 'set x2range [',velmin,':',velmax,']'
         write(40,*) 'set yrange [-0.1:1.4]'
         write(40,*)

!       Define constant function at transmission = 0
         write(40,*) '# Define constant function at transmission = 0/1'
         write(40,*) 't_0(x) = 0.0'
         write(40,*) 't_1(x) = 1.0'

!       Plot in x-y scale
         write(40,*) '# Plot data file'
         write(40,*) 'plot '''//trim(linefile)//''' u ($2):($4) axes x1y1 '//
     &   'w l lt 1 lw 2 lc rgb "web-green" title "flux" \'
         write(40,*) ', '''//trim(linefile)//''' u ($2):($5) axes x1y1 '//
     &   'w l lt 1 lw 2 lc rgb "red" title "flux + conv" \'
         write(40,*) ', '''//trim(linefile)//''' u ($2):($3) axes x1y1 '//
     &   'w histeps lt 1 lw 1 lc rgb "black" title "flux + conv + noise" \'
         write(40,*) ', t_0(x) w l lt 0 lw 2 lc rgb "black" notitle \'
         write(40,*) ', t_1(x) w l lt 0 lw 2 lc rgb "black" notitle \'
         write(40,*) '#, '''//trim(linefile)//''' u ($1):($3) axes x2y1 '//
     &   'w l lw 2 notitle \'
         write(40,*)

!       Close file (do not forget!)
        close(40)

        end subroutine create_plotfile
!       ------------------------------------------------------------------------

!       ------------------------------------------------------------------------
        subroutine create_plotfile_multiplet(datfile,linefile,gpfile,psline,sn)

!       To plot a 3D color map from a data file with three columns
!       (x:y:z)
!       where each 'iso_line' must be separated by a blank line
!
        use set_precision
        use abs_lines, only: IONS, num_ions
        use physical

        implicit none

        real(kind=doubleR), intent(in) :: sn
        character(len=256), intent(inout) :: datfile
        character(len=256), intent(in) :: linefile, gpfile, psline

        integer(kind=singleI) :: i, ionindex

        real(kind=doubleR) :: zabs
        real(kind=doubleR), allocatable :: wl_0(:), f_osc(:), damp(:)

        integer(kind=singleI) :: num_trans

        real(kind=doubleR) :: velmin, velmax

        real(kind=doubleR) :: margin

        character(len=256) :: fontpath, fontfile, timestamp

        integer(kind=singleI) :: datetime(8)
        integer(kind=singleI) :: clock
        character(len=10) :: date, time, zone
        character(len=10) :: datetime_str(8)

!       ------------------------------------------------------------------------
!       Get time stamp (include from fitfile to uniquely identify files)
        call date_and_time(date, time, zone, datetime)
        call system_clock(clock)

!       Write datime into a string (for later use)
        write(datetime_str(:),'(i5)') datetime(:)
        timestamp = trim(adjustl(datetime_str(1)))//'/'//
     &  trim(adjustl(datetime_str(2)))//'/'//trim(adjustl(datetime_str(3)))
     &  //'-'//trim(adjustl(datetime_str(4)))//'-'//
     &  trim(adjustl(datetime_str(5)))//'.'//trim(adjustl(datetime_str(6)))
     &  //'.'//trim(adjustl(datetime_str(7)))//'.'//
     &  trim(adjustl(datetime_str(8)))

!       ----------------------------------------------------------------
!       Redefine datfile name (to be used as title for the plot) to
!       to replace underscores by minuses
        do i=1,len_trim(datfile)
         if (datfile(i:i).eq.'_') datfile(i:i)='-'
        end do

!       Open file
        open(40,file=trim(gpfile))

         write(40,*) '# ------------------------------------------------'
         write(40,*) '# line profile plot'
         write(40,*) '# Generated by abs_line_profile_multiplet'
         write(40,*) '# ------------------------------------------------'
         write(40,*)
         write(40,*) '# Reset for a clean start'
         write(40,*) 'reset'
         write(40,*)
         write(40,*) '# Set general plot options'
         write(40,*)
         write(40,*) '# Key'
         write(40,*) 'set key top right'
         write(40,*)

!       Define fontpath for fancy symbols
         fontpath='/usr/share/texmf/fonts/type1/bluesky/cm/'
         write(40,*) '# Set font path'
         write(40,*) '# set fontpath '''//trim(fontpath)//''
         write(40,*) '# Set term x11 and font cmsy10.pfb for special '
         write(40,*) '# symbols (CMSY10 font) in OMS encoding'
         write(40,*) '# (see table ~/ps_fontfile_doc.ps)'
         write(40,*)

!       Define fontfile for fancy symbols
         fontfile='cmsy10.pfb'

         write(40,*) 'set term post portrait enhanced color dashlength 1'
         write(40,*)
         write(40,*) '# Set output filename'
         write(40,*) 'set output "'//trim(psline)//'"'
         write(40,*)
         write(40,*) '# For fancy symbol fonts'
         write(40,*) 'set encoding iso_8859_1'
         write(40,*)

!       Set title of plot; size is modified via {/=<size> <text>}
         write(40,*) '# Set title'
         write(40,*) 'set title "{/=12 '//trim(datfile)//'}"'
         write(40,*)

         write(40,*) '# Set time stamp'
         write(40,*) '#set label "',clock,'" at graph 0.8, 0.9'
         write(40,*) '# centered, below title'
         write(40,*) '#set label "{/=6 '//trim(timestamp)//'}" at '
     &   //'graph 0.45, 1.02'
         write(40,*) '# top right edge'
         write(40,*) '#set label "{/=6 '//trim(timestamp)//'}" at '
     &   //'graph 0.9, 1.08'
         write(40,*)

!       ------------------------------------------------------------------------
         write(40,*) '# Set xy-range'
         write(40,*) 'ckms=', c_kms
         velmin =  -200
         velmax =  200
         write(40,*) 'set xrange [',velmin,':',velmax,']'
         write(40,*) 'set yrange [-0.1:1.4]'
         write(40,*)

!       Define constant function at transmission = 0
         write(40,*) '# Define constant function at transmission = 0/1'
         write(40,*) 't_0(x) = 0.0'
         write(40,*) 't_1(x) = 1.0'

!       ------------------------------------------------------------------------
        DO ionindex=1,num_ions
!       ------------------------------------------------------------------------

!       ion-specific quantities

!       absorption redshift
	zabs = IONS(ionindex)%component(1)%z_abs

!       ------------------------------------------------------------------------
!       for each ion a new multiplot environment

         write(40,'(a,e10.4,a)') '# multiplot environment'
         write(40,'(a,e10.4,a)') 'set multiplot'

!       ------------------------------------------------------------------------
!       panels

!       margin scale
        margin = 0

!       number of transitions per ion
	num_trans = IONS(ionindex)%num_transitions

	if (allocated(wl_0)) deallocate(wl_0)
	if (allocated(f_osc)) deallocate(f_osc)
	if (allocated(damp)) deallocate(damp)
	allocate(wl_0(1:num_trans))
	allocate(f_osc(1:num_trans))
	allocate(damp(1:num_trans))

        DO i=1,num_trans

!       transition-specific quantities

	wl_0(i) = IONS(ionindex)%transition(i)%lambda_0
	f_osc(i) = IONS(ionindex)%transition(i)%f_osc
	damp(i) = IONS(ionindex)%transition(i)%big_gamma

!       ------------------------------------------------------------------------
!       set margin scale
         margin =  (1.0d0 - 1.2d-1)/dble(num_trans)

!       ------------------------------------------------------------------------
         write(40,'(a,e10.4,a)') '# margins'
         write(40,'(a,e10.4,a)') 'set tmargin screen ', 0.95 - (i-1)*margin
         write(40,'(a,e10.4,a)') 'set bmargin screen ', 0.95 - (i)*margin


        if (i.gt.1)
     &   write(40,'(a,1pe8.2,a)') 'unset title'

!       ------------------------------------------------------------------------
         write(40,*) '# Set text labels'
         write(40,'(a,1pe8.2,a)') 'unset label'

        if (i.eq.1)
     &   write(40,'(a,1pe8.2,a)') 'set label "{/=12 S/N=',
     &   sn,'}" tc rgb "royalblue" at graph 0.05, 0.9'

        if (i.eq.1)
     &   write(40,'(a,1pe8.2,a)') 'set label "{/=12 S/N=',
     &   sn,'}" tc rgb "royalblue" at graph 0.05, 0.9'

         write(40,'(a,1pe10.4,a)') 'set label "{/=10 {/Symbol G}'
     &   //' = ', damp(i),' s^{-1}}" at graph 0.7, 0.16'

!       NOTE: the format statement 0p is necessary, otherwise the output after
!       the 1p directive is shifted by one decimal place!

         write(40,'(a,1pe10.4,0p,a,f5.3)') 'set label "{/=10 f'
     &   //'_{osc} = ', f_osc(i),'}" at graph 0.7, 0.16+', 0.02*num_trans

         write(40,'(a,f7.2,a,f5.3)') 'set label "{/=10 {/Symbol l}'
     &   //'_{0} = ', wl_0(i),' \305}" at graph 0.7, 0.16+', 0.04*num_trans

!       ------------------------------------------------------------------------
        if (i.eq.num_trans) then

!       axes number formatting
         write(40,*)
         write(40,*) '# tics format (default)'
         write(40,*) 'set xtics mirror format "{/=14% g}"'
         write(40,*) 'set ytics format "{/=14% g}"'
         write(40,*)

!       axes labels; size is modified via {/=<size> <text>}
         write(40,*) '# Set axes label'
         write(40,*) 'set xlabel "{/=14 vel [kms^{-1}]"'
         write(40,*) 'set ylabel "{/=14 Transmission}"'
         write(40,*)

        else

!       axes number formatting
         write(40,*)
         write(40,*) '# tics format (default)'
         write(40,*) 'set xtics mirror format " "'
         write(40,*) 'set ytics format "{/=14% g}"'
         write(40,*)

!       axes labels; size is modified via {/=<size> <text>}
         write(40,*) '# Set axes label'
         write(40,*) 'set xlabel ""'
         write(40,*) 'set ylabel "{/=14 Transmission}"'
         write(40,*)

        end if

!       Set minor tics on both axes
         write(40,*) '# Set minor tics on all axes'
         write(40,*) 'set mxtics'
         write(40,*) 'set mytics'
         write(40,*)


!       Plot in x-y scale
         write(40,*) '# Plot data file'
         write(40,*) 'plot '''//trim(linefile)//
     &   ''' u (ckms*log(($1)/(',wl_0(i),'*(1.+',zabs,')))):($2) '//
     &   'w histeps lt 1 lw 1 lc rgb "black" title "flux + conv + noise" \'
         write(40,*) ', t_0(x) w l lt 0 lw 2 lc rgb "black" notitle \'
         write(40,*) ', t_1(x) w l lt 0 lw 2 lc rgb "black" notitle \'
         write(40,*)

        END DO ! over transitions

!       ------------------------------------------------------------------------
        write(40,'(a,e10.4,a)') '# exit multiplot environment'
        write(40,'(a,e10.4,a)') 'unset multiplot'

!       ------------------------------------------------------------------------
        END DO ! over ions
!       ------------------------------------------------------------------------

!       ------------------------------------------------------------------------
!       Close file (do not forget!)
        close(40)

        end subroutine create_plotfile_multiplet
!       ========================================================================
