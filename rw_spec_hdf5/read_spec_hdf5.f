        
        program read_spec_hdf5

!        (C) Thorsten Tepper Garcia 2009
!        Last modified: 8.07.2009
!        Last modified: 6.02.2010
!
!       USES hdf5_wrapper module in:
!
!       /home/volans/tepper/hdf5/HDF5_Wrapper/lib/ 
!
!       Reads in a short/long spectrum generated by SpecWizard and
!       ouputs the spectrum in ascii format compatible with ifit.
!       An HDF5 file <spectype>_z<redshift>_<ion>_fit_SN<S/N>.hdf5 is
!       output to ~tepper/ifitnot/output_data/<simulation>/
!       This directory MUST exist, otherwise the program will CRASH.
!
!       An ascii file <spectype>_<ion>.rsh is output to the directory
!       where this program is called
!
!       The file <spectype>_z<redshift>_<ion>_fit_SN<S/N>.hdf5 contains:
!       1) Header with information about the spectrum
!       2) Spectrum (denoise, noise, etc.)
!       3) ifit fit and related parameters (after processing with
!       profiles.f)
!
!       This code must be run EXCLUSIVE with auto_min_hdf5 (ifit)
!       See ~/ifitnot/.
!
!       Modules

        use hdf5_wrapper
        use common_strings
        use common_nums
        use common_arrays_read
        use common_arrays_rw
        use ifit_par, only: bparmin, fwhm_avp, spectrum_cycled_str

!       ------------------------------------------------------------------------
!       Variables declaration
!       ------------------------------------------------------------------------
        implicit none
        
        intrinsic dexp
        
        integer :: idum, nseed
        integer :: i
        integer :: rank
        integer, dimension(10) :: dim
        
        double precision, parameter :: CLIGHT=2.99792458d+5 ! in km/s
        double precision :: minnoise = 1.0d-2 ! min noise level
        double precision, parameter :: readout_noise = 1 !rms in electron/ADU
        !ron values range between 4 and 8 for e.g. STIS detectors
        
        double precision :: gasdev
        
        character(len=256) :: var, path, atomfile,
     +        redshift_box_str, redshift_qso_str, redshift_abs_max_str,
     +        dir, SpecWizard_noise_flag_str

        logical :: flag, file_exists
        logical :: generate_random_noise        !flag to generate noise
!       ------------------------------------------------------------------------
!       Define program error, warning, and status message
!        errmsg='ERROR: read_spec_hdf5 ... '
!        warnmsg='WARNING: read_spec_hdf5 ... '
!        statmsg='STATUS: read_spec_hdf5 ... '

!        The lines below are meant to print the different
!        messages in different colors

!        In red=31
        errmsg=CHAR(27)//'[1;31mERROR: read_spec_hdf5 ...'//
     &        CHAR(27)//'[0m'
!        In yellow=33
        warnmsg=CHAR(27)//'[1;33mWARNING: read_spec_hdf5 ...'//
     &        CHAR(27)//'[0m'
!        In green=32
        statmsg=CHAR(27)//'[1;32mSTATUS: read_spec_hdf5 ...'//
     &        CHAR(27)//'[0m'

!       ------------------------------------------------------------------------
!       Get arguments
        
        call read_input_params_r

!       ------------------------------------------------------------------------
!       Computation
!       ------------------------------------------------------------------------
!       Define home directory
        
        homedir = '/home/volans/tepper/'

!       ------------------------------------------------------------------------
!       Reading atomic data
!       ------------------------------------------------------------------------
!       Converting OWLS ion names into general format
!        (see ~/ifitnot/ions.dat)
!       Only H, O, N and Ne for now
!        Distinction between h1 and h1_bla because ifit fitting parameters
!        are set differently
!        'ion_sw' is the actual OWLS ion designation, and it does not make
!        a distinction between h1 and h1_bla

        select case(ion)
        
        case('h1')
         ion_name = 'HI_Lya'
         ion_sw = trim(ion)

        case('h1_bla')
         ion_name = 'HI_Lya_BLA'
         ion_sw = 'h1'

        case('o6')
         ion_name = 'OVI_1032'
         ion_sw = trim(ion)

        case('n5')
         ion_name = 'NV_1238'
         ion_sw = trim(ion)

        case('ne8')
         ion_name = 'NeVIII_770'
         ion_sw = trim(ion)

        case('c4')
         ion_name = 'CIV_1548'
         ion_sw = trim(ion)

        case('si3')
         ion_name = 'SiIII_1206'
         ion_sw = trim(ion)

        case default
         write(6,*) trim(errmsg)//'Ion ', trim(ion),
     &         ' not yet implemented.'
         if ((trim(spectype).eq.'short').and.(trim(ion).eq.'all')) then
          write(6,*) trim(errmsg)//'Need to specify an ion for short spectra.'
         end if
         stop 1

        end select
!       ------------------------------------------------------------------------
!       Reading Morton+2003 atomic data tables

!       Define atom-data file
        
        atomfile=trim(homedir)//'/ifitnot/ions.dat'
        
!       File exists?
         inquire(file=atomfile,exist=file_exists)

!       If file doesn't exist, stop cleanly
         if (.not.file_exists) then
          write(6,*) trim(errmsg)//'File '//trim(atomfile)//' does not exist'
          stop 1
         end if

!       Reads in restframe wavelength (in Angstroem), oscillator strength
!       and gamma-value (in Hz) of the corresponding transitions
        flag=.true.
        open(20, file = trim(atomfile), status='old')
         do 5 while (flag)
          read(20,*,end=9) ion_str, wl_central, f_osc
          if (trim(ion_str) .eq. trim(ion_name)) then
           flag=.false.
          end if
  5         continue
  9         continue
        close(20)
        if (flag) then
         print*, trim(errmsg)//'Ion ', trim(ion_name), ' not found.'
         stop 1
        end if

!       ========================================================================
!       SPECTRUM TYPE
!       ========================================================================

        SELECT CASE(spectype)
        
!       ========================================================================
!       SHORT SPECTRUM

        case('short')

!       ------------------------------------------------------------------------
!       Open SpecWizard spectrum file HDF5

!       Directory containing SpecWizard spectrum files (short and long)

         dir = trim(homedir)//trim(specdir)

         infile=trim(dir)//trim(spectype)//'/output_data/'
     1         //trim(simulation)//'/'//trim(specwizfile)

!       File exists?
         inquire(file=infile,exist=file_exists)

!       If file doesn't exist, stop cleanly
         if (.not.file_exists) then
          write(6,*) trim(errmsg)//'File '//trim(infile)//' does not exist'
          stop 1
         end if

         call hdf5_open_file(file_id, trim(infile), readonly=.true.)

!       ------------------------------------------------------------------------
!        Get time stamp (included to uniquely identify files)
         call hdf5_read_attribute(file_id,'Header/TimeStamp',datetime) 

!       ------------------------------------------------------------------------
!       Get redshift of box and convert it to string (for outfile name)

         call hdf5_read_attribute(file_id,'/Header/Redshift',z_box)
         write(redshift_box_str, '(f5.3)') z_box
         call compare_str(redshift_box_str,redshift_str,'redshift')

!        Get spectral properties

         groupname='/Parameters/SpecWizardRuntimeParameters'

         var=trim(groupname)//'/nveloc'
         call hdf5_read_attribute(file_id,trim(var),nveloc)

         groupname='/Parameters/SpecWizardRuntimeParameters'

         groupname=trim(groupname)//'/InstrumentProperties'

         var=trim(groupname)//'/PixSizekms_Before_convolution'
         call hdf5_read_attribute(file_id,trim(var),pxsize_noconv)

!        Check if NET spectrum has been convolved; recall that the
!        optical depth spectrum of individual ions is NEVER convolved
!        by SW; this is done here, if the following flag = True

         var=trim(groupname)//'/Do_Convolve_Spectrum'
         call hdf5_read_attribute(file_id,trim(var),spectrum_convolved_str)
         
         if (trim(spectrum_convolved_str).eq.'True') then
          spectrum_convolved = .true.
          spectrum_convolved_str = 'TRUE'

         else if (trim(spectrum_convolved_str).eq.'False') then
          spectrum_convolved = .false.
          spectrum_convolved_str = 'FALSE'
         
         else
          write(*,*) trim(errmsg)//'Non valid "do-convolve-spectrum"'
     &          //' flag: '//trim(spectrum_convolved_str)
               stop 1
         end if

!        Instrumental Line Spread Function (LSF; corresponding FWHM)
         if (spectrum_convolved) then
          var=trim(groupname)//'/FWHM_kms'
          call hdf5_read_attribute(file_id,trim(var),fwhm_kms)
         else
          fwhm_kms = 0.0d0
         end if 

!        Check if noise has been generated, i.e. if the
!        DataSet 'Gaussian_deviate' has been written into file
         
         groupname='/Parameters/SpecWizardRuntimeParameters'

         var=trim(groupname)//'/NoiseParameters/Generate_Noise'
         call hdf5_read_attribute(file_id,trim(var),
     &         SpecWizard_noise_flag_str)

!       ------------------------------------------------------------------------
!       Allocating memory

         allocate(v_Hubble(1:nveloc))
         allocate(wavelength(1:nveloc))
         allocate(flux(1:nveloc))       
         allocate(opticaldepth(1:nveloc))

!        initalise
         v_Hubble(:) = 0.0d0
         wavelength(:) = 0.0d0
         flux(:) = 1.0d0
         opticaldepth(:) = 0.0d0

!       ------------------------------------------------------------------------
!       Read v_Hubble and transform to observed wavelength
!       According to Joop Schaye (see SpecWizard):
!
!       lambda_observed = lambda_rest*exp(v/c)*(1+z)
!
!       True for box sizes smaller than R_H = c/H_0

         var='/VHubble_KMpS'
         call hdf5_read_data(file_id,trim(var),v_Hubble(1:nveloc))
         wavelength(:) = wl_central*dexp(v_Hubble(:)/CLIGHT)*(1.0d0 + z_box)

!       ------------------------------------------------------------------------
!       read optical depth spectrum of given ion; transform to flux

         path='/Spectrum'//trim(spec_id)//'/'//trim(ion_sw)
         var=trim(path)//'/OpticalDepth'
         call hdf5_read_data(file_id,trim(var),opticaldepth(1:nveloc))

!        avoid underflow of dexp(-tau)
         where (opticaldepth.gt.(-1.0d0*dlog(dble(tiny(1.0e0)))))
     &   opticaldepth = -1.0d0*dlog(dble(tiny(1.0e0)))

         flux(:) = dexp(-1.0d0*opticaldepth(:))

!       ------------------------------------------------------------------------
!       Read integrated ion column density along LOS

         path='/Spectrum'//trim(spec_id)//'/'//trim(ion_sw)
         var=trim(path)//'/LogTotalIonColumnDensity'
         call hdf5_read_data(file_id,trim(var),log_tot_coldens_ion)

!       ------------------------------------------------------------------------
!       Allocate memory for Gaussian random numbers,
!        For the case that generate_random_noise = .false., Gaussian
!        distributed random numbers (mean = 0, dispersion = 1) are read
!        from the SpecWizard specwizfile; otherwise they are generated here
!
!        By default, do not generate Gaussian random numbers, but read
!        them from SpecWizard file; however, do this only if the
!        DataSet 'Gaussian_deviate' has been written into file; if the
!        latter is not the case, Gaussian random number will be generated
!        in case that the parameter noisy = .true.
        
         if (trim(SpecWizard_noise_flag_str).eq.'True') then
          generate_random_noise = .false.
         else
          generate_random_noise = .true.
          write(6,*) trim(warnmsg)//'Gaussian random numbers not '//
     &          'available in file '//trim(specwizfile)//'; will be generated ...'
         end if
        
         allocate(gaussdev(1:nveloc))

         if (.not.generate_random_noise) then
 
!       Read Gaussian random numbers

          path='/Spectrum'//trim(spec_id)
          var=trim(path)//'/Gaussian_deviate'
          call hdf5_get_dimensions(file_id,trim(var), rank, dim)
          call compare_num_int(nveloc,dim(1),var)
          call hdf5_read_data(file_id,trim(var),gaussdev)
        
         else

!        Generate Gaussian random numbers (mean = 0, dispersion = 1)

!       Initialization seed (has to be a negative integer)

          call system('echo $RANDOM > seed')        !taking system's RAND
          open(90, FILE='seed')
          read(90,'(I5)') nseed
          close(90)
          call system ('rm -f seed')
          idum= -INT(ABS(nseed+1))
          
          do i=1,nveloc
           gaussdev(i) = gasdev(idum)
          end do
        
         end if

!       ------------------------------------------------------------------------
!       Close SpecWizard spectra file HDF5

         call hdf5_close_file(file_id)

!       ========================================================================
!        Convolution with instrumental Line Spread Function (LSF)
!       ========================================================================
!        Note that SpecWizard only convolves the net flux, i.e. the spec-
!        trum containing absorption by ALL transitions. The optical-
!        depth spectra on the contrary are not convolved; therefore, when
!        fitting a spectrum for a single ion, the flux has to be first
!        convolved with the desired FWHM; in order to do this, I shameless-
!        ly stole the corresponding subroutines from SW...

!        TO INCLUDE: convolution with different PSF, e.g. COS, either in
!        analytical or numerical form
!
        if (spectrum_convolved.and.(fwhm_kms.gt.0.0d0)) call convolve_gaussian()

!       ------------------------------------------------------------------------
!       Read ifit fit parameters (from ~/ifitnot/ifit_parameters.<ion>)
!       ------------------------------------------------------------------------
         
         call inparam(ion_name)

!       ------------------------------------------------------------------------
!        IMPORTANT: check at this stage if the minimum Doppler parameter
!        to be fitted, bparmin, satisfies:

!        (b [km/s])^2 >= (1/ln 2)*(0.5 FWHM [km/s])^2
!
!        Abort if not, since fitting process crucially depends on this!
!        Note that the required precision is only 10^{-2}, which is ok

        if (bparmin.lt.
     &        1.0d-2*int(1.0d2*(0.5*fwhm_kms)/DSQRT(DLOG(2.0d0)))) then
         write(6,*) trim(warnmsg)//'Minimum Doppler parameter ', bparmin,
     &         'does not correspond to current instrumental LSF (FWHM):',
     &         fwhm_kms, '. "b_min" must be at least (0.5*FWHM)/sqrt(ln 2) = ',
     &         (0.5*fwhm_kms)/sqrt(dlog(2.0d0)), '.'
        end if

!        where FWHM corresponds to the instrumental Line Spread Function (LSF)

!        Check that FWHM here and in ifit file coincide

        if (fwhm_avp.ne.fwhm_kms) then
         write(6,*) trim(warnmsg)//'Instrumental broadening in ifit ',
     &         fwhm_avp,
     &         'does not correspond to adopted instrumental LSF (FWHM) in SpecWizard:',
     &         fwhm_kms, '.'
        end if

!       ------------------------------------------------------------------------
!       Generate noise (gaussian, wavelength independent)
!       ------------------------------------------------------------------------
!       Allocating memory for noise, sigma, and gaussdev arrays

         allocate(sigma(1:nveloc))        
         allocate(flux_noisy(1:nveloc))
         allocate(noise(1:nveloc))

         if (noisy) then

!       Computation of sigma differs from the approach in SpecWizard:
!
!        Here:
!
!        sigma^2  = minnoise^2 +[flux/S/N)]^2
!
!        while in SpecWizard
!
!        sigma = minnoise + [1/(S/N) - minnoise]*flux
!

!        The minimum noise value should be constrained by the given S/N:
          minnoise = min(minnoise,1.0d-1/signaltonoise)

          do i=1,nveloc
!           sigma(i) = minnoise + (1.0d0/signaltonoise - minnoise)*flux(i)
           sigma(i) = sqrt( minnoise**2 + (flux(i)/signaltonoise)**2 )
           noise(i) = sigma(i)*gaussdev(i)
           flux_noisy(i) = flux(i) + noise(i)
          end do
         
          else

!       Set a minimum value for noise sigma (required by ifit)
!       Corresponds to a S/N of 1000, set by read_input_params_r
!        The way it's done is a bit inconsistent for now, since the noise
!        is randomly added, and repeated calling with noise = F will lead
!        to different realizations of the noise; however, the S/N is so
!        high that it should barely make a difference

          do i=1,nveloc
!           sigma(i) = minnoise + (1.0d0/signaltonoise - minnoise)*flux(i)
           sigma(i) = sqrt( minnoise**2 + (flux(i)/signaltonoise)**2 )
           noise(i) = sigma(i)*gaussdev(i)
           flux(i) = flux(i) + noise(i)
          end do
         
         end if

!       ------------------------------------------------------------------------
!       Check that no pixel has negative flux (causes ifit to crash...);
!        if so, use a positive noise value
        where(flux_noisy.lt.0.0d0) flux_noisy = flux+abs(noise)

!       ------------------------------------------------------------------------
!       Create/write HDF5 fit file
!       ------------------------------------------------------------------------
!       This file contains (for each los):
!       -original spectrum w/o noise
!       -noisy spectrum + noise info (S/N, noise, gaussian deviates)
!       The idea now is to include for each spectrum different S/N
!       for a single realisation of the gaussian noise, and different
!       realisations of the latter for the same S/N (not yet done!)
!       
!       AFTER processing through ifit and profiles, the following
!       are appended:
!       -fit (flux vs. wavelength vs. v_Hubble) + ifit_parameters info
!       -list of line parameters (z_abs, Nion, b-value) + errors

!       What else to include?

!       ------------------------------------------------------------------------
!        define hdf5 fit file name

!        NOTE: the line below has been changed by one containing the full
!        ifit directory path (to call code from every directory)
!         dir = 'output_data/'//trim(simulation)//'/'
         dir = trim(homedir)//'/'//trim(ifit_dir)//'/output_data/'//
     &         trim(simulation)//'/'
        
         outfile = trim(dir)//trim(spectype)//'_z'//trim(redshift_str)//
     &         '_'//trim(ion)//'_fit_SN'//trim(signaltonoise_str)//'.hdf5'
        
!       File exists already?
         inquire(file=outfile,exist=file_exists)
         
         if (.not.file_exists) then

!       Initialize total number of spectra for first call
          total_los = 1
        
!       Allocate memory for spectra list

          allocate(spec_list(1:total_los))

!       Write current first spectrum ID (only first call)

          spec_list(total_los) = specid_int

!       Create file, header and ifit-fitparameters group, and close
         
          call hdf5_create_file(file_id,trim(outfile))
          call create_header_short(file_id)
          call include_ifit_fitparams(file_id)
          call hdf5_close_file(file_id)

         else

!       If file exists, open it and perform sanity check of spectrum
!       status first, and then header, global fitparameter values
!       and close

          call hdf5_open_file(file_id,trim(outfile))
          call spectrum_status_check_r(file_id,spec_id)
          call header_short_sanity_check(file_id)
          call fitparams_sanity_check(file_id)
          call hdf5_close_file(file_id)

         end if

!       ------------------------------------------------------------------------
!       Write data to output file (one group per spectrum)
!       ------------------------------------------------------------------------
!         Open file
         call hdf5_open_file(file_id,trim(outfile))

!       Do only if spectrum has not already been written; the way this
!       is currently done saves time only by preventing a crash (since
!       an existent group/dataset/etc. in HDF5 format cannot be rewritten);
!       it also allows to rewrite the file <spectype>_<ion>.rsh without
!       the need of running all over again

         if (.not.spectrum_written) then

!       Create group for current spectrum

          groupname='/Spectrum'//trim(spec_id)
         
          call hdf5_create_group(file_id,trim(groupname))

!       Initialize Spectrum status by setting flags to default value .FALSE.

!       This flag gives the status processing by this very program; change
!       only after successful writing (see below)

          spectrum_written_str = 'FALSE'
          spectrum_written = .false.
          attributename=trim(groupname)//'/Spectrum_Written'
          call hdf5_write_attribute(file_id,trim(attributename),'FALSE')
         
!       This flag gives the status in relationship with profiles_hdf5
!       (profiles.f) processing; it is only changed by write_fit_hdf5
!       after succesful processing
!       
          spectrum_fitted_str = 'FALSE'
          spectrum_fitted = .false.
          attributename=trim(groupname)//'/Spectrum_Fitted'
          call hdf5_write_attribute(file_id,trim(attributename),'FALSE')

!       Write total column density of ion computed by SpecWizard
!        directly from simulation
          
          datasetname=trim(groupname)//'/LogTotalIonColumnDensity_Sim'
          call hdf5_write_data(file_id,trim(datasetname),log_tot_coldens_ion)

!       Write flux, wavelength, etc. for case with noise...

          if (noisy) then
         
           datasetname=trim(groupname)//'/Flux_NoNoise'
           call hdf5_write_data(file_id,trim(datasetname),flux)

           datasetname=trim(groupname)//'/Flux_Noisy'
           call hdf5_write_data(file_id,trim(datasetname),flux_noisy)

           datasetname=trim(groupname)//'/Wavelength_Ang'
           call hdf5_write_data(file_id,trim(datasetname),wavelength)
        
           datasetname=trim(groupname)//'/V_Hubble_Kms'
           call hdf5_write_data(file_id,trim(datasetname),v_Hubble)
        
           datasetname=trim(groupname)//'/Noise_Sigma'
           call hdf5_write_data(file_id,trim(datasetname),sigma)
        
           datasetname=trim(groupname)//'/Gaussian_Random'
           call hdf5_write_data(file_id,trim(datasetname),gaussdev)

          else
         
!       ...or without noise

           datasetname=trim(groupname)//'/Flux_NoNoise'
           call hdf5_write_data(file_id,trim(datasetname),flux)

           datasetname=trim(groupname)//'/Wavelength_Ang'
           call hdf5_write_data(file_id,trim(datasetname),wavelength)
        
           datasetname=trim(groupname)//'/V_Hubble_Kms'
           call hdf5_write_data(file_id,trim(datasetname),v_Hubble)
                  
          end if

!       Close output file with new spectrum successfuly written
          call hdf5_close_file(file_id)

!       ------------------------------------------------------------------------
!       If file already existed, and since new spectrum was written
!       successfuly, open the file again, update list and total number
!       of spectra in header; also, irrespective of file already existent
!       or just created, update        written status of spectrum, and close
!       (this is done in the subroutine 'update_header' below; therefore
!       the file is closed in the previous line)

          if (file_exists) then

           call update_header(outfile)

          end if
          
          call spectrum_status_set(outfile,spec_id,'Spectrum_Written','TRUE')
          spectrum_written = .true.

         else !spectrum already written
         

!       If spectrum successfully written to file but not fitted, update
!       noise-related arrays using the values already stored (for case
!       with noise) to avoid inconsistency between values stored and newly
!       fitted spectrum
          
          if ((.not.spectrum_fitted).and.(noisy)) then

!       Define group for current spectrum

           groupname='/Spectrum'//trim(spec_id)
           
           datasetname=trim(groupname)//'/Flux_Noisy'
           call hdf5_read_data(file_id,trim(datasetname),flux_noisy)

           datasetname=trim(groupname)//'/Noise_Sigma'
           call hdf5_read_data(file_id,trim(datasetname),sigma)

          end if

!       Close output file
          call hdf5_close_file(file_id)

         end if !spectrum written?

!       ------------------------------------------------------------------------
!       Create files compatible with ifit
!       ------------------------------------------------------------------------
!        Define ascii output-file name
         outfile_avp = trim(simulation)//'_'//trim(spectype)//'_spec'//
     &         trim(spec_id)//'_z'//trim(redshift_str)//'_'//trim(ion)//'_SN'
     &         //trim(signaltonoise_str)//'.rsh'

         write(6,'(a)') trim(statmsg)//'Writing spectrum...'
         
         open(10,file=trim(outfile_avp))
         
         if (noisy) then
         
          do i=1,nveloc
           write(10,*) wavelength(i), flux_noisy(i), sigma(i)
          end do
          
         else
         
          do i=1,nveloc
           write(10,*) wavelength(i), flux(i), sigma(i)
          end do
         
         end if
         
         close(10)

!       ------------------------------------------------------------------------
!        Destroy arrays when not longer needed
         call dealloc_arrays_read

!       ========================================================================
!       LONG SPECTRUM

        CASE ('long')

!       ------------------------------------------------------------------------
!       Open SpecWizard spectra file HDF5

!       Directory containing SpecWizard spectra files (short and long)

         dir = trim(homedir)//trim(specdir)

         infile=trim(dir)//trim(spectype)//'/output_data/'
     1         //trim(simulation)//'/'//trim(specwizfile)

!       File exists?
         inquire(file=infile,exist=file_exists)

!       If file doesn't exist, stop cleanly
         if (.not.file_exists) then
          write(6,*) trim(errmsg)//'File '//trim(infile)//' does not exist'
          stop 1
         end if

         call hdf5_open_file(file_id, trim(infile), readonly=.true.)

!       ------------------------------------------------------------------------
!        Get time stamp (included to uniquely identify files)
         call hdf5_read_attribute(file_id,'Header/TimeStamp',datetime) 

!       ------------------------------------------------------------------------
!       Get minimum and maximum redshift for absorption, and QSO redshift

         groupname='/Parameters/SpecWizardRuntimeParameters'

         var=trim(groupname)//'/SpectrumProperties/z_min'
         call hdf5_read_attribute(file_id,trim(var),z_min)
                  
         var=trim(groupname)//'/SpectrumProperties//z_max'
         call hdf5_read_attribute(file_id,trim(var),z_max)                  
         write(redshift_abs_max_str, '(f5.3)') z_max
         call compare_str(redshift_abs_max_str,redshift_str,'redshift')

         var=trim(groupname)//'/SpectrumProperties//z_qso'
         call hdf5_read_attribute(file_id,trim(var),z_qso)
         write(redshift_qso_str, '(f5.3)') z_qso

!        Get spectral properties

         var=trim(groupname)//'/InstrumentProperties/PixSizekms_Before_'
     &         //'convolution'
         call hdf5_read_attribute(file_id,trim(var),pxsize_noconv)

!        Check if NET spectrum has been convolved; recall that the
!        optical depth spectrum of individual ions is NEVER convolved
!        by SW; this is done here, if the following flag = TRUE

         var=trim(groupname)//'/InstrumentProperties/Do_Convolve_Spectrum'
         call hdf5_read_attribute(file_id,trim(var),spectrum_convolved_str)

         if (trim(spectrum_convolved_str).eq.'True') then
          spectrum_convolved = .true.
          spectrum_convolved_str = 'TRUE'

         else if (trim(spectrum_convolved_str).eq.'False') then
          spectrum_convolved = .false.
          spectrum_convolved_str = 'FALSE'
         
         else
          write(*,*) trim(errmsg)//'Non valid "do-convolve-spectrum"'
     &          //' flag: '//trim(spectrum_convolved_str)
               stop 1
         end if

!        Instrumental Line Spread Function (LSF; corresponding FWHM)
         if (spectrum_convolved) then
          var=trim(groupname)//'/InstrumentProperties/FWHM_kms'
          call hdf5_read_attribute(file_id,trim(var),fwhm_kms)
         else
          fwhm_kms = 0.0d0
         end if 

         var=trim(groupname)//'/SpectrumProperties/PixSize_Angstrom'
         call hdf5_read_attribute(file_id,trim(var),pxsize_ang)

!        Check if noise has been generated, i.e. if the
!        DataSet 'Gaussian_deviate' has been written into file

         var=trim(groupname)//'/NoiseParameters/Generate_Noise'
         call hdf5_read_attribute(file_id,trim(var),SpecWizard_noise_flag_str)

!       ------------------------------------------------------------------------
!       Get dimensions for wavelength array AND flux/optical depth

         var='/Wavelength_Ang'
         call hdf5_get_dimensions(file_id,trim(var), rank, dim)
         nveloc = dim(1)

!       ------------------------------------------------------------------------
!       Allocating memory
         
         allocate(wavelength(1:nveloc))
         allocate(flux(1:nveloc))

         if (trim(ion) .ne. 'all') then
          allocate(opticaldepth(1:nveloc))
         end if         

!       ------------------------------------------------------------------------
!       Reading wavelength

         call hdf5_read_data(file_id,trim(var),wavelength(1:nveloc))

!       ------------------------------------------------------------------------
!       Reading net flux containing absorption by ALL ions or the
!        optical depth spectrum of a particular ion

         if (trim(ion) .eq. 'all') then
          path='/Spectrum'//trim(spec_id)
          var=trim(path)//'/Flux'
          call hdf5_read_data(file_id,trim(var),flux(1:nveloc))
         else
          path='/Spectrum'//trim(spec_id)//'/'//trim(ion_sw)
          var=trim(path)//'/RedshiftSpaceOpticalDepthOfStrongestTransition'
          call hdf5_read_data(file_id,trim(var),opticaldepth(1:nveloc))
          flux(:) = dexp(-opticaldepth(:))
         end if

!       ------------------------------------------------------------------------
!       Allocate memory for Gaussian random numbers,
!        For the case that generate_random_noise = .false., Gaussian
!        distributed random numbers (mean = 0, dispersion = 1) are read
!        from the SpecWizard specwizfile; otherwise they are generated here
!
!        By default, do not generate Gaussian random numbers, but read
!        them from SpecWizard file; however, do this only if the
!        DataSet 'Gaussian_deviate' has been written into file; if the
!        latter is not the case, Gaussian random number will be generated
!        in case that the parameter noisy = .true.
        
         if (trim(SpecWizard_noise_flag_str).eq.'True') then
          generate_random_noise = .false.
         else
          generate_random_noise = .true.
          write(6,*) trim(warnmsg)//'Gaussian random numbers not '//
     &          'available in file '//trim(specwizfile)//'; will be generated ...'
               stop 1
         end if
        
         allocate(gaussdev(1:nveloc))

         if (.not.generate_random_noise) then
 
!       Read Gaussian random numbers in SpecWizard file

          path='/Spectrum'//trim(spec_id)
          var=trim(path)//'/Gaussian_deviate'
          call hdf5_read_data(file_id,trim(var),gaussdev)
        
         else

!        Generate Gaussian random numbers (mean = 0, dispersion = 1)

!       Initialization seed (has to be a negative integer)

          call system('echo $RANDOM > seed')        !taking system's RAND
          open(90, FILE='seed')
          read(90,'(I5)') nseed
          close(90)
          call system ('rm -f seed')
          idum= -INT(ABS(nseed+1))
          
          do i=1,nveloc
           gaussdev(i) = gasdev(idum)
          end do
        
         end if

!       ------------------------------------------------------------------------
!       close SpecWizard spectra file HDF5

         call hdf5_close_file(file_id)

!       ========================================================================
!        Convolution with instrumental Line Spread Function (LSF)
!       ========================================================================
!        IMPORTANT: LONG spectra MUST be already convolved (done by SW!)
!
!        Note that SpecWizard only convolves the net flux, i.e. the spec-
!        trum containing absorption by ALL transitions. The optical-
!        depth spectra on the contrary are not modified; therefore, when
!        fitting a spectrum for a single ion, the flux has to be first
!        convolved with the desired FWHM; in order to do this, I shameless-
!        ly stole the corresponding subroutines from SW...

!        if (spectrum_convolved.and.fwhm_kms.gt.0.0d0) call convolve_gaussian()

!       ------------------------------------------------------------------------
!       Read ifit fit parameters (from ~/ifitnot/ifit_parameters.<ion>)
!       ------------------------------------------------------------------------
 
         call inparam(ion_name)

!       ------------------------------------------------------------------------
!        IMPORTANT: check at this stage if the minimum Doppler parameter
!        to be fitted, bparmin, satisfies:

!        (b [km/s])^2 >= (1/ln 2)*(0.5 FWHM [km/s])^2
!
!        Abort if not, since fitting process crucially depends on this!
!        Note that the required precision is only 10^{-2}, which is ok

        if (bparmin.lt.
     &        1.0d-2*int(1.0d2*(0.5*fwhm_kms)/DSQRT(DLOG(2.0d0)))) then
         write(6,*) trim(errmsg)//'Minimum Doppler parameter ', bparmin,
     &         'does not correspond to current instrumental LSF (FWHM):',
     &         fwhm_kms, '. "b_min" must be at least (0.5*FWHM)/sqrt(ln 2) = ',
     &         (0.5*fwhm_kms)/sqrt(dlog(2.0d0)), '.'
              stop 1
        end if

!        where FWHM corresponds to the instrumental Line Spread Function (LSF)

!       ------------------------------------------------------------------------
!        IMPORTANT: if fitting a long spectrum, make sure that is is not        cycled!
!        The corresponding flag is set in the ifit parameter file
        
        if ((trim(spectype).eq.'long').and.
     &        (trim(spectrum_cycled_str).eq.'TRUE')) then
         
         write(6,*) trim(errmsg)//'Long spectra shall not be cycled!'
         write(6,*) 'Please modified corresponding flag in ifit '//
     &         'parameter file'
              stop 1
        
        end if
!       ------------------------------------------------------------------------
!       Generate noise (gaussian)
!       ------------------------------------------------------------------------
!       Allocating memory for noise, sigma, and gaussdev arrays

         allocate(sigma(1:nveloc))
         allocate(flux_noisy(1:nveloc))
         allocate(noise(1:nveloc))

         if (noisy) then

!       Computation of sigma differs from the approach in SpecWizard:
!
!        Here:
!
!        sigma^2  = minnoise^2 +[flux/S/N)]^2
!
!        while in SpecWizard
!
!        sigma = minnoise + [1/(S/N) - minnoise]*flux
!

!        The minimum noise value should be constrained by the given S/N:
          minnoise = min(minnoise,1.0d-1/signaltonoise)
         
          do i=1,nveloc
!           sigma(i) = minnoise + (1.0d0/signaltonoise - minnoise)*flux(i)
           sigma(i) = sqrt( minnoise**2 + (flux(i)/signaltonoise)**2 )
           noise(i) = sigma(i)*gaussdev(i)
           flux_noisy(i) = flux(i) + noise(i)
          end do

         else

!       Set a minimum value for noise sigma (required by ifit)
!       Corresponds to a S/N of 1000, set by read_input_params_r
!        The way it's done is a bit inconsistent for now, since the noise
!        is randomly added, and repeated calling with noise = F will lead
!        to different realizations of the noise; however, the S/N is so
!        high that it should barely make a difference

          do i=1,nveloc
!           sigma(i) = minnoise + (1.0d0/signaltonoise - minnoise)*flux(i)
           sigma(i) = sqrt( minnoise**2 + (flux(i)/signaltonoise)**2 )
           noise(i) = sigma(i)*gaussdev(i)
           flux(i) = flux(i) + noise(i)
          end do
         
         end if

!       ------------------------------------------------------------------------
!       Check that no pixel has negative flux; if so, use a positive
!        noise value
        where(flux_noisy.lt.0.0d0) flux_noisy = flux+abs(noise)

!       ------------------------------------------------------------------------
!       Create HDF5 fit file
!       ------------------------------------------------------------------------
!       This file contains (for each los):
!       -original spectrum without noise
!       -noisy spectrum + noise info (S/N, noise, gaussian deviates)
!       
!       AFTER processing through ifit, the following are appended:
!       -fit (flux vs. wavelength) + ifit_parameters info
!       -list of line parameters (z_abs, Nion, b-value) + errors

!       What else to include?

!        NEED to cycle spectra in order to avoid features at the
!        edges. If and the amount by which spectra are cycled should be
!        stored in the header. Note that only the cycled spectra are passed
!        to ifit, while the original spectra are stored, as usual. The
!        reason behind is to faciliatate the computation of e.g. optical-
!        depth weighted quantities (see ~/abs_line_statistics_hdf5). Other-
!        wise the arrays in the original SW file would need to be cycled
!        as well.

!       ------------------------------------------------------------------------
!        Create file name

!        NOTE: the line below has been changed by one containing the full
!        ifit directory path (to call to code from every directory)
!         dir = 'output_data/'//trim(simulation)//'/'
         dir = trim(homedir)//'/'//trim(ifit_dir)//'/output_data/'//
     &         trim(simulation)//'/'

!       Should be z_qso or z_abs_max be used in file name??? For now use
!        z_abs_max
        
!        outfile = trim(dir)//trim(spectype)//'_z'//trim(redshift_qso_str)//
!     &'_'//trim(ion)//'_fit.hdf5'
         outfile = trim(dir)//trim(spectype)//'_z'//trim(redshift_str)//
     &         '_'//trim(ion)//'_fit_SN'//trim(signaltonoise_str)//'.hdf5'
        
!       File exists already?
         inquire(file=outfile,exist=file_exists)
         
         if (.not.file_exists) then

!       Initialize total number of spectra for first call
          total_los = 1

!       Allocate memory for spectra list

          allocate(spec_list(total_los))

!       Write current first spectrum ID (only first call)

          spec_list(total_los) = specid_int

!       Create file, header and ifit-fitparameters group

          call hdf5_create_file(file_id,trim(outfile))
          call create_header_long(file_id)
          call include_ifit_fitparams(file_id)
          call hdf5_close_file(file_id)

         else

!       If file exists, open it and perform sanity check of spectrum
!       status first, and then header, global fitparameter values
         
          call hdf5_open_file(file_id,trim(outfile))
          call spectrum_status_check_r(file_id,spec_id)
          call header_long_sanity_check(file_id)
          call fitparams_sanity_check(file_id)
          call hdf5_close_file(file_id)
          
         end if

!       ------------------------------------------------------------------------
!       Write data to output file (one group per spectrum)
!       ------------------------------------------------------------------------
!         Open file
         call hdf5_open_file(file_id,trim(outfile))

!       Do only if spectrum has not already been written; the way this
!       is currently done saves time only by preventing a crash (since
!       an existent group/dataset/etc. in HDF5 format cannot be rewritten);
!       it also allows to rewrite the file <spectype>_<ion>.rsh without
!       the need of running all over again

         if (.not.spectrum_written) then

!       Create group for current spectrum

          groupname='/Spectrum'//trim(spec_id)
         
          call hdf5_create_group(file_id,trim(groupname))

!       Initialize Spectrum status by setting flags to default value .FALSE.

!       This flag gives the status processing by this very program; change
!       only after successful writing (see below)
          spectrum_written_str = 'FALSE'
          spectrum_written = .false.
          attributename=trim(groupname)//'/Spectrum_Written'
          call hdf5_write_attribute(file_id,trim(attributename),'FALSE')
         
!       This flag gives the status in relationship with profiles_hdf5
!       (profiles.f) processing; it is only changed by write_fit_hdf5
!       after succesful processing
!       
          spectrum_fitted_str = 'FALSE'
          spectrum_fitted = .false.
          attributename=trim(groupname)//'/Spectrum_Fitted'
          call hdf5_write_attribute(file_id,trim(attributename),'FALSE')

!       Write flux, wavelength, etc.

          datasetname=trim(groupname)//'/Flux_NoNoise'
          call hdf5_write_data(file_id,trim(datasetname),flux)

!        If noise = false, the following arrays contains a spectrum with
!        noise added assuming S/N = 1000

          datasetname=trim(groupname)//'/Flux_Noisy'
          call hdf5_write_data(file_id,trim(datasetname),flux_noisy)

          datasetname=trim(groupname)//'/Wavelength_Ang'
          call hdf5_write_data(file_id,trim(datasetname),wavelength)
        
          datasetname=trim(groupname)//'/Noise_Sigma'
          call hdf5_write_data(file_id,trim(datasetname),sigma)
        
          datasetname=trim(groupname)//'/Gaussian_Random'
          call hdf5_write_data(file_id,trim(datasetname),gaussdev)


!       Close output file with new spectrum successfuly written
          call hdf5_close_file(file_id)

!       ------------------------------------------------------------------------
!       If file already existed, and since new spectrum was written
!       successfuly, open the file again, update list and total number
!       of spectra in header; also, irrespective of file already existent
!       or just created, update        written status of spectrum, and close
!       (this is done in the subroutine 'update_header' below; therefore
!       The file is closed in the previous line)

          if (file_exists) then

           call update_header(outfile)

          end if !file previously existent
          
          call spectrum_status_set(outfile,spec_id,'Spectrum_Written','TRUE')
          spectrum_written = .true.
        

         else !spectrum already written

!       If spectrum successfully written to file but not fitted, update
!       noise-related arrays using the values already stored (for case
!       with noise) to avoid inconsistency between values stored and newly
!       fitted spectrum

          groupname='/Spectrum'//trim(spec_id)

          if ((.not.spectrum_fitted).and.(noisy)) then
           
           datasetname=trim(groupname)//'/Flux_Noisy'
           call hdf5_read_data(file_id,trim(datasetname),flux_noisy)

           datasetname=trim(groupname)//'/Noise_Sigma'
           call hdf5_read_data(file_id,trim(datasetname),sigma)

          end if

!       Close output file
          call hdf5_close_file(file_id)

         end if !spectrum written?

!       ------------------------------------------------------------------------
!       Create files compatible with ifit
!       ------------------------------------------------------------------------
!        Define ascii output-file name
         outfile_avp = trim(simulation)//'_'//trim(spectype)//'_spec'//
     &         trim(spec_id)//'_z'//trim(redshift_str)//'_'//trim(ion)//'_SN'
     &         //trim(signaltonoise_str)//'.rsh'

         write(6,'(a)') trim(statmsg)//'Writing spectrum...'
         
         open(10,file=trim(outfile_avp))
         
         if (noisy) then
         
          do i=1,nveloc
           write(10,*) wavelength(i), flux_noisy(i), sigma(i)
          end do
          
         else
         
          do i=1,nveloc
           write(10,*) wavelength(i), flux(i), sigma(i)
          end do
         
         end if
         
         close(10)

!       ------------------------------------------------------------------------
!        Destroy arrays when not longer needed
         call dealloc_arrays_read

!       ========================================================================
!       Invalid spectrum type
        
        CASE DEFAULT

         write(*,*) trim(errmsg)//'Not valid spectrum type: ', trim(spectype)
         stop 1

        END SELECT !spectrum type: short/long
!       ========================================================================

        write(6,'(a)') trim(statmsg)//'Done.'
!       ------------------------------------------------------------------------
        end program
!       ------------------------------------------------------------------------
